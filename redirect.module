<?php
// $Id$

/**
 * @defgroup redirect_api Redirection API
 * @{
 * Functions related to URL redirects.
 *
 * @} End of "defgroup redirect_api".
 */

/**
 * Modules should return this value from hook_redirect_access() to allow access
 * to a redirect.
 */
define('REDIRECT_ACCESS_ALLOW', 'allow');

/**
 * Modules should return this value from hook_redirect_access() to deny access
 * to a redirect.
 */
define('REDIRECT_ACCESS_DENY', 'deny');

/**
 * Modules should return this value from hook_redirect_access() to not affect
 * redirect access.
 */
define('REDIRECT_ACCESS_IGNORE', NULL);

/**
 * Implements hook_hook_info().
 */
function redirect_hook_info() {
  $hooks = array(
    'redirect_load_multiple',
    'redirect_load_by_source_alter',
    'redirect_access',
    'redirect_presave',
    'redirect_insert',
    'redirect_update',
    'redirect_delete',
    'redirect_alter',
    'redirect_cache_clear',
  );

  $hooks = array_combine($hooks, $hooks);
  foreach ($hooks as $hook => $info) {
    $hooks[$hook] = array('group' => 'redirect');
  }
  return $hooks;
}

/**
 * Implements hook_permission().
 */
function redirect_permission() {
  $permissions['administer redirects'] = array(
    'title' => t('Administer URL redirections'),
  );
  return $permissions;
}

/**
 * Implements hook_help().
 */
function redirect_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/config/search/redirect/404':
      $output = '<p>' . t('This page lists all paths that have resulted in 404 errors and do not yet have any redirects assigned to them.') . '</p>';
      break;
    case 'admin/reports/page-not-found':
      break;
  }
  return $output;
}

/**
 * Implements hook_menu().
 */
function redirect_menu() {
  $items['admin/config/search/redirect'] = array(
    'title' => 'URL redirects',
    'description' => 'Redirect users from one URL to another.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('redirect_list_form'),
    'access arguments' => array('administer redirects'),
    'file' => 'redirect.admin.inc',
  );
  $items['admin/config/search/redirect/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/config/search/redirect/add'] = array(
    'title' => 'Add redirect',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('redirect_edit_form'),
    'access callback' => 'redirect_access',
    'access arguments' => array('create', 'redirect'),
    'file' => 'redirect.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items['admin/config/search/redirect/edit/%redirect'] = array(
    'title' => 'Edit redirect',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('redirect_edit_form', 5),
    'access callback' => 'redirect_access',
    'access arguments' => array('update', 5),
    'file' => 'redirect.admin.inc',
  );
  $items['admin/config/search/redirect/delete/%redirect'] = array(
    'title' => 'Delete redirect',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('redirect_delete_form', 5),
    'access callback' => 'redirect_access',
    'access arguments' => array('delete', 5),
    'file' => 'redirect.admin.inc',
  );
  $items['admin/config/search/redirect/settings'] = array(
    'title' => 'Settings',
    'description' => 'Configure behavior for URL redirects.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('redirect_settings_form'),
    'access arguments' => array('administer redirects'),
    'file' => 'redirect.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 50,
  );

  // If the database logging module is enabled, add special 404 listing pages.
  if (module_exists('dblog')) {
    $items['admin/config/search/redirect/404'] = array(
      'title' => 'Fix 404 pages',
      'description' => 'Add redirects for 404 pages.',
      'page callback' => 'redirect_404_list',
      'access arguments' => array('administer redirects'),
      'file' => 'redirect.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 20,
    );
    $items['admin/reports/page-not-found/redirect'] = array(
      'title' => 'Fix 404 pages with URL redirects',
      'page callback' => 'drupal_goto',
      'page arguments' => array('admin/config/search/redirect/404'),
      'access arguments' => array('administer redirects'),
      'type' => MENU_LOCAL_ACTION,
    );
  }

  return $items;
}

/**
 * Implements hook_url_inbound_alter().
 */
function redirect_url_inbound_alter(&$path, $original_path, $path_language) {
  // Redirect to canonical URLs.
  if ($path && variable_get('redirect_canonical', 1)) {
    $alias = drupal_get_path_alias($path, $path_language);
    if ($alias != $path && $alias != $original_path) {
      return redirect_redirect(array('redirect' => $alias, 'type' => 'global'));
    }

    // Redirect from default entity paths to the proper entity path.
    if ($path_entity = redirect_load_entity_from_path($path)) {
      $uri = entity_uri($path_entity['entity_type'], $path_entity['entity']);
      if ($path != $uri['path']) {
        //return redirect_redirect(array('redirect' => $uri['path'], 'redirect_options' => $uri['options'], 'type' => 'global'));
      }
    }
  }
}

/**
 * Implements hook_entity_info_alter().
 */
function redirect_entity_info_alter(&$info) {
  $info['node']['default path'] = 'node/[id]';
  $info['taxonomy_term']['default path'] = 'taxonomy/term/[id]';
  $info['user']['default path'] = 'user/[id]';
}

/**
 * Implements hook_init().
 */
function redirect_init() {
  if (!redirect_can_redirect()) {
    return;
  }

  $current_path = current_path();
  $current_langcode = $GLOBALS['language']->language;
  $current_query = drupal_get_query_parameters();
  if ($redirect = redirect_load_by_source($current_path, $current_langcode, $current_query)) {
    //redirect_redirect($redirect);
  }

  $request_uri = $original_uri = ltrim(request_uri(), '/');

  // Redirect from non-clean URLs to clean URLs.
  if (variable_get('redirect_global_clean', 1) && variable_get('clean_url', 0) && strpos($request_uri, '?q=') !== FALSE) {
    $request_uri = str_replace('?q=', '', $request_uri);
  }

  if (strpos($request_uri, 'index.php') !== FALSE) {
    $request_uri = str_replace('index.php', '', $request_uri);
  }

  $request_uri = trim($request_uri, '/');

  if ($request_uri != $original_uri) {
    //redirect_redirect(array('redirect' => $request_uri, 'type' => 'global'));
  }
}

/**
 * Implements hook_cron().
 */
function redirect_cron() {
  // Purge inactive self-managed redirects from the database.
  redirect_purge_inactive_redirects();
}

/**
 * Implements hook_exit().
 */
function redirect_exit($destination = NULL) {
  // If the current page is being cached, track it.
  if (drupal_get_http_header('Location') && $rid = drupal_get_http_header('X-Redirect-ID')) {
    // Ensure the database is loaded. This is only the next bootstrap step
    // after DRUPAL_BOOTSTRAP_DATABASE
    drupal_bootstrap(DRUPAL_BOOTSTRAP_DATABASE);
    db_update('redirect')
      ->fields(array('last_used' => REQUEST_TIME))
      ->expression('count', 'count + 1')
      ->condition('rid', $rid)
      ->execute();
  }
}

/**
 * Implements hook_node_delete().
 */
function redirect_node_delete($node) {
  redirect_delete_by_entity_path('node', $node);
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function redirect_taxonomy_term_delete($term) {
  redirect_delete_by_entity_path('taxonomy_term', $term);
}

/**
 * Implements hook_user_cancel().
 */
function redirect_user_cancel($edit, $account, $method) {
  switch ($method) {
    case 'user_cancel_reassign':
    case 'user_cancel_delete':
      redirect_delete_by_entity_path('user', $account);
      break;
  }
}

/**
 * Implements hook_views_api().
 */
function redirect_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'redirect') . '/views',
  );
}

/**
 * Implements hook_page_build().
 *
 * Adds an action on 404 pages to create a redirect.
 */
function redirect_page_build(&$page) {
  if (redirect_is_current_page_404() && user_access('administer redirects')) {
    $actions['add'] = array(
      'title' => t('Add an URL redirect from this page to another location'),
      'href' => 'admin/config/search/redirect/add',
      'query' => array('source' => current_path()) + drupal_get_destination(),
    );
    $page['content']['system_main']['actions'] = array(
      '#theme' => 'links',
      '#links' => $actions,
      '#attributes' => array('class' => array('action-links')),
      '#weight' => -100,
    );
  }
}

/**
 * Load an URL redirect from the database.
 *
 * @param $rid
 *   The URL redirect ID.
 * @return
 *   An URL redirect array, or FALSE if loading failed.
 *
 * @ingroup redirect_api
 */
function redirect_load($rid) {
  $redirects = redirect_load_multiple(array($rid));
  return reset($redirects);
}

/**
 * Load an URL redirect from the database by {redirect}.hash.
 *
 * @param $hash
 *   The hash of the URL redirect.
 * @return
 *   An URL redirect array, or FALSE if loading failed.
 *
 * @ingroup redirect_api
 */
function redirect_load_by_hash($hash) {
  $redirects = redirect_load_multiple(array(), array('hash' => $hash));
  return reset($redirects);
}

/**
 * Load multiple URL redirects from the database by {redirect}.source.
 *
 * @param $source
 *   The source of the URL redirect.
 * @return
 *   An array of URL redirect arrays indexed by redirect IDs.
 *
 * @see redirect_load_multiple()
 * @see _redirect_uasort()
 * @see redirect_compare_array_recursive()
 *
 * @ingroup redirect_api
 */
function redirect_load_by_source($source, $language = LANGUAGE_NONE, array $query = array()) {
  // Run a case-insensitive query for matching RIDs first.
  $rid_query = db_select('redirect');
  $rid_query->addField('redirect', 'rid');
  if ($source != variable_get('site_frontpage', 'node')) {
    $rid_query->condition('source', db_like($source), 'LIKE');
  }
  else {
    $source_condition = db_or();
    $source_condition->condition('source', db_like($source), 'LIKE');
    $source_condition->condition('source', '');
    $rid_query->condition($source_condition);
  }
  $rid_query->condition('language', array($language, LANGUAGE_NONE));
  $rids = $rid_query->execute()->fetchCol();

  if ($rids && $redirects = redirect_load_multiple($rids)) {
    // Narrow down the list of candidates.
    foreach ($redirects as $rid => $redirect) {
      if (!empty($redirect['source_options']['query'])) {
        if (empty($query) || !redirect_compare_array_recursive($redirect['source_options']['query'], $query)) {
          unset($redirects[$rid]);
          continue;
        }
      }

      // Add a case sensitive matches condition to be used in sorting.
      if ($source !== $redirect['source']) {
        $redirects[$rid]['weight'] = 1;
      }
    }

    if (!empty($redirects)) {
      // Sort the redirects in the proper order.
      uasort($redirects, '_redirect_uasort');

      // Allow other modules to alter the redirect candidates before selecting the top one.
      $context = array('language' => $language, 'query' => $query);
      drupal_alter('redirect_load_by_source', $redirects, $source, $context);

      return !empty($redirects) ? reset($redirects) : FALSE;
    }
  }

  return FALSE;
}

/**
 * Load multiple URL redirects from the database.
 *
 * @param $rids
 *   An array of redirect IDs.
 * @param $conditions
 *   An array of conditions on the {redirect} table in the form 'field' =>
 *   $value.
 * @return
 *   An array of URL redirect arrays indexed by redirect IDs.
 *
 * @ingroup redirect_api
 */
function redirect_load_multiple(array $rids = array(), array $conditions = array()) {
  // Build and execute the query.
  $query = db_select('redirect');
  $query->fields('redirect');
  if (count($rids)) {
    $conditions['rid'] = $rids;
  }
  foreach ($conditions as $field => $value) {
    $query->condition($field, $value);
  }
  $query->orderBy('rid', 'DESC');
  $query->addTag('redirect_load');
  $redirects = $query->execute()->fetchAllAssoc('rid', PDO::FETCH_ASSOC);

  // Perform unserialization.
  foreach ($redirects as $rid => $redirect) {
    $redirects[$rid]['source_options'] = unserialize($redirect['source_options']);
    $redirects[$rid]['redirect_options'] = unserialize($redirect['redirect_options']);
  }

  // Let modules modify the redirects after loading.
  module_invoke_all('redirect_load_multiple', $redirects);

  return $redirects;
}

/**
 * Determine whether the current user may perform the given operation on the
 * specified redirect.
 *
 * @param $op
 *   The operation to be performed on the redirect. Possible values are:
 *   - "create"
 *   - "update"
 *   - "delete"
 * @param $redirect
 *   The redirect array on which the operation is to be performed, or redirect
 *   type (e.g. 'feedburner') for the "create" operation.
 * @param $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function redirect_access($op, $redirect, $account = NULL) {
  global $user;

  $rights = &drupal_static(__FUNCTION__, array());

  if (!$redirect || !in_array($op, array('create', 'update', 'delete'), TRUE)) {
    // If there was no redirect to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $user;
  }

  $cid = isset($redirect['rid']) ? $redirect['rid'] : $redirect;

  // Return cached value if access already checked for this redirect, user and op.
  if (isset($rights[$account->uid][$cid][$op])) {
    return $rights[$account->uid][$cid][$op];
  }

  // Administrators can access all redirects.
  if (user_access('administer redirects', $account)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  // We grant access to the redirect if both of the following conditions are met:
  // - No modules say to deny access.
  // - At least one module says to grant access.
  $access = module_invoke_all('redirect_access', $op, $redirect, $account);
  if (in_array(REDIRECT_ACCESS_DENY, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }
  elseif (in_array(REDIRECT_ACCESS_ALLOW, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  return FALSE;
}

/**
 * Save an URL redirect.
 *
 * @param $redirect
 *   An URL redirect array passed by reference to be saved.
 * @return
 *   The saved and altered URL redirect array.
 *
 * @ingroup redirect_api
 */
function redirect_save(array &$redirect) {
  $redirect += array(
    'rid' => NULL,
    'type' => 'redirect',
    'uid' => $GLOBALS['user']->uid,
    'source_options' => array(),
    'redirect_options' => array(),
    'language' => LANGUAGE_NONE,
    'status_code' => 0,
    'count' => 0,
    'last_used' => 0,
    'hash' => '',
  );

  // Let modules modify the redirect before it is saved to the database.
  module_invoke_all('redirect_presave', $redirect);

  $hash = redirect_get_redirect_hash($redirect);
  if (empty($redirect['rid']) || $hash !== $redirect['hash']) {
    // Only new or changed redirects reset the last used value.
    $redirect['hash'] = $hash;
    $redirect['count'] = 0;
    $redirect['last_used'] = 0;

    if (!empty($redirect['rid'])) {
      $old_redirect = redirect_load($redirect['rid']);
      redirect_cache_clear($old_redirect);
    }
  }

  if (empty($redirect['rid'])) {
    drupal_write_record('redirect', $redirect, array());
    module_invoke_all('redirect_insert', $redirect);
  }
  else {
    drupal_write_record('redirect', $redirect, array('rid'));
    module_invoke_all('redirect_update', $redirect);
  }

  redirect_cache_clear($redirect);

  return $redirect;
}

/**
 * Clear a appropriate caches when a redirect is saved or deleted.
 */
function redirect_cache_clear(array $redirect) {
  if (variable_get('redirect_page_cache', 0)) {
    redirect_page_cache_clear($redirect['source']);
  }

  module_invoke_all('redirect_cache_clear', $redirect);
}

/**
 * Delete a single URL redirect.
 *
 * @param $rid
 *   The ID of the redirect to delete.
 *
 * @ingroup redirect_api
 */
function redirect_delete($rid) {
  return redirect_delete_multiple(array($rid));
}

/**
 * Delete any redirects associated with a path or any of its sub-paths.
 *
 * Given a source like 'node/1' this function will delete any redirects that
 * have that specific source or any sources that match 'node/1/%'.
 *
 * @param $path
 *   An string with an internal Drupal path.
 *
 * @ingroup redirect_api
 */
function redirect_delete_by_path($path) {
  $query = db_select('redirect');
  $query->addField('redirect', 'rid');
  $query_or = db_or();
  $query_or->condition('source', db_like($path), 'LIKE');
  $query_or->condition('source', db_like($path . '/') . '%', 'LIKE');
  $query_or->condition('redirect', db_like($path), 'LIKE');
  $query_or->condition('redirect', db_like($path . '/') . '%', 'LIKE');
  $query->condition($query_or);
  $rids = $query->execute()->fetchCol();

  if ($rids) {
    return redirect_delete_multiple($rids);
  }
}

/**
 * Delete an entity URL alias and any of its sub-paths.
 *
 * This function also checks to see if the default entity URI is different from
 * the current entity URI and will delete any of the default aliases.
 *
 * @param $entity_type
 *   A string with the entity type.
 * @param $entity
 *   An entity object.
 *
 * @ingroup redirect_api
 */
function redirect_delete_by_entity_path($entity_type, $entity) {
  $uri = entity_uri($entity_type, $entity);
  redirect_delete_by_path($uri['path']);

  $info = entity_get_info($entity_type);
  if (isset($info['default path'])) {
    list($id, , ) = entity_extract_ids($entity_type, $entity);
    $default_path = str_replace('[id]', $id, $info['default path']);
    if ($uri['path'] !== $default_path) {
      redirect_delete_by_path($default_path);
    }
  }
}

/**
 * Delete multiple URL redirects.
 *
 * @param $rids
 *   An array of redirect IDs to delete.
 *
 * @ingroup redirect_api
 */
function redirect_delete_multiple(array $rids) {
  if ($redirects = redirect_load_multiple($rids)) {
    db_delete('redirect')
      ->condition('rid', array_keys($redirects))
      ->execute();

    // Let modules react to the individual redirects being deleted.
    foreach ($redirects as $rid => $redirect) {
      module_invoke_all('redirect_delete', $redirect);
      redirect_cache_clear($redirect);
    }
  }
}

/**
 * Purge inactive redirects from the database.
 *
 * @param $types
 *   An array of redirect types to remove. Default is only the self-managed
 *   'redirect'. If not provided all redirect types will be eligible for
 *   removal.
 * @param $interval
 *   The number of seconds to subtract from the current time and used to
 *   find the inactive redirects.
 *
 * @return
 *   An array of redirect IDs that were deleted or FALSE if none were.
 */
function redirect_purge_inactive_redirects(array $types = array('redirect'), $interval = NULL) {
  if (isset($interval)) {
    $interval = variable_get('redirect_purge_inactive', 0);
  }

  if (!$interval || (variable_get('redirect_page_cache', 0) && !variable_get('page_cache_invoke_hooks', TRUE))) {
    // If serving redirects from the page cache is enabled and hooks are not
    // executed during page caching, then we cannot track when a redirect is
    // used. Therefore, we cannot remove unused redirects.
    return FALSE;
  }

  $query = db_select('redirect');
  $query->addField('redirect', 'rid');
  if (!empty($types)) {
    $query->condition('type', $types);
  }
  $query->condition('last_used', REQUEST_TIME - $interval, '<');
  $query->addTag('redirect_purge');
  $rids = $query->execute()->fetchCol();

  if (count($rids)) {
    redirect_delete_multiple($rids);
    watchdog('redirect', format_plural(count($rids), 'Removed 1 inactive redirect from the database.', 'Removed @count inactive redirects from the database.'));
    return $rids;
  }
}

/**
 * Perform an URL redirect.
 *
 * @param $redirect
 *   An optional URL redirect array.
 *
 * @ingroup redirect_api
 */
function redirect_redirect(array $redirect = array()) {
  // First check if we're in an infinite loop.
  $session_id = session_id();
  if (flood_is_allowed('redirection', 5, 15, $session_id ? $session_id : NULL)) {
    flood_register_event('redirection', 60, $session_id ? $session_id : NULL);
  }
  else {
    watchdog('redirect', 'Infinite loop stopped.');
    drupal_set_message('Oops, looks like this request tried to create an infinite loop. We do not allow such things here. We are a professional website!');
    return FALSE;
  }

  $redirect += array(
    // Use the current internal URL as the default redirection URL.
    'redirect' => current_path(),
    'redirect_options' => array(),
    'type' => 'manual',
    'callback' => 'redirect_goto',
  );
  $redirect['redirect_options'] += array(
    'query' => array(),
  );

  if (empty($redirect['status_code'])) {
    $redirect['status_code'] = variable_get('redirect_default_status_code', 301);
  }

  if (variable_get('redirect_passthrough_querystring', FALSE)) {
    // Preserve the current query parameters in the redirect.
    $redirect['redirect_options']['query'] += drupal_get_query_parameters();
  }

  // Prevent the destination query parameter from overriding this redirect.
  //if (isset($_GET['destination'])) {
    // Simply unset the parameter since it has already been passed into
    // $options['query'] in the previous code.
  //  unset($_GET['destination']);
  //}

  // Allow other modules to alter the redirect before passing to drupal_goto().
  drupal_alter('redirect', $redirect);

  // Continue if the redirect has not been disabled by hook_redirect_alter().
  if (isset($redirect['redirect']) && $redirect['redirect'] !== FALSE && function_exists($redirect['callback'])) {
    // Perform the actual redirect.
    $callback = $redirect['callback'];
    $callback($redirect);
  }
}

/**
 * Redirect callback; perform an URL redirect.
 */
function redirect_goto(array $redirect) {
  $redirect['redirect_options']['absolute'] = TRUE;
  $url = url($redirect['redirect'], $redirect['redirect_options']);
  drupal_add_http_header('Location', $url);
  drupal_add_http_header('Status', redirect_status_code_options($redirect['status_code']));
  if (!empty($redirect['rid'])) {
    drupal_add_http_header('X-Redirect-ID', $redirect['rid']);
  }

  if (!variable_get('redirect_page_cache', 0) || !variable_get('cache', 0) || !drupal_page_is_cacheable()) {
    drupal_exit($url);
  }

  // @see drupal_exit()
  if (drupal_get_bootstrap_phase() == DRUPAL_BOOTSTRAP_FULL) {
    if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {
      module_invoke_all('exit', $url);
    }
    drupal_session_commit();
    if (variable_get('cache', 0)) {
      // We must output something to allow the request to be cached.
      echo ' ';
      drupal_page_set_cache();
    }
  }

  exit;
}

function redirect_get_redirect_hash(array $redirect) {
  $hash = array(
    'source' => $redirect['source'],
    'language' => $redirect['language'],
  );
  if (!empty($redirect['source_options']['query'])) {
    $hash['source_query'] = $redirect['source_options']['query'];
  }
  redirect_sort_recursive($hash, 'ksort');
  return drupal_hash_base64(serialize($hash));
}

/**
 * Clear a page from the page cache.
 */
function redirect_page_cache_clear($path = '*', array $options = array()) {
  if ($path != '*') {
    $options['absolute'] = TRUE;
    $options['query'] = '';
    $path = url($path, $options);
  }
  cache_clear_all($path, 'cache_page', TRUE);
}

/**
 * Given a path determine if it is an entity default path.
 *
 * @param $path
 *   The internal path. The id of the entity should be in the string as '[id]'.
 * @return
 *   An array with the entity type and the loaded entity object.
 */
function redirect_load_entity_from_path($path) {
  $entity_paths = &drupal_static(__FUNCTION__);

  if (!isset($entity_paths)) {
    $entity_paths = array();
    foreach (entity_get_info() as $entity_type => $entity_info) {
      if (isset($entity_info['default path'])) {
        $default_path = $entity_info['default path'];
        $default_path = preg_quote($default_path, '/');
        $default_path = str_replace('\[id\]', '(\d+)', $default_path);
        $entity_paths[$entity_type] = $default_path;
      }
    }
  }

  foreach ($entity_paths as $entity_type => $default_path) {
    if (preg_match("/^{$default_path}$/", $path, $matches)) {
      if ($entity = entity_load($entity_type, array($matches[1]))) {
        return array('entity_type' => $entity_type, 'entity' => reset($entity));
      }
      break;
    }
  }
}

/**
 * Check the ability to perform redirects with the current request context.
 *
 * This function checks the following conditions:
 * - If the PHP entry point is the root index.php file.
 * - If PHP is not running as CLI.
 * - If the site is not offline or in install/update mode.
 * - If the curerent page is not an admin page (check can be disabled).
 * - If the current request does not have any POST data since a redirect
 *   may interrupt form submission.
 *
 * @return
 *   TRUE if redirections can be performed, or FALSE otherwise.
 */
function redirect_can_redirect() {
  static $can_redirect;

  if (!isset($can_redirect)) {
    $can_redirect = TRUE;
    $current_path = current_path();

    if ($_SERVER['SCRIPT_NAME'] != $GLOBALS['base_path'] . 'index.php') {
      // Do not redirect if the root script is not /index.php.
      $can_redirect = FALSE;
    }
    elseif (drupal_is_cli()) {
      // If this is a command line request (Drush, etc), skip processing.
      $can_redirect = FALSE;
    }
    elseif (variable_get('site_offline', 0) || defined('MAINTENANCE_MODE')) {
      // Do not redirect in offline or maintenance mode.
      $can_redirect = FALSE;
    }
    elseif (!variable_get('redirect_global_admin_paths', 0) && path_is_admin($current_path)) {
      // Do not redirect on admin paths.
      $can_redirect = FALSE;
    }
    elseif (!empty($_POST)) {
      // Do not redirect if this is a post request with data.
      $can_redirect = FALSE;
    }
  }

  return $can_redirect;
}

/**
 * Compare tha all values and associations in one array match another array.
 *
 * We cannot use array_diff_assoc() here because we need to be recursive.
 *
 * @param $match
 *   The array that has the values.
 * @param $haystack
 *   The array that will be searched for values.
 * @return
 *   TRUE if all the elements of $match were found in $haystack, or FALSE
 *   otherwise.
 */
function redirect_compare_array_recursive($match, $haystack) {
  foreach ($match as $key => $value) {
    if (!array_key_exists($key, $haystack)) {
      return FALSE;
    }
    elseif (is_array($value)) {
      if (!is_array($haystack[$key])) {
        return FALSE;
      }
      elseif (!redirect_compare_array_recursive($value, $haystack[$key])) {
        return FALSE;
      }
    }
    elseif ($value != $haystack[$key]) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Sort an array recusively.
 *
 * @param $array
 *   The array to sort, by reference.
 * @param $callback
 *   The sorting callback to use (e.g. 'sort', 'ksort', 'asort').
 *
 * @return
 *   TRUE on success or FALSE on failure.
 */
function redirect_sort_recursive(&$array, $callback = 'sort') {
  $result = $callback($array);
  foreach ($array as $key => $value) {
    if (is_array($value)) {
      $result &= redirect_sort_recursive($array[$key], $callback);
    }
  }
  return $result;
}

/**
 * Load a language object by its language code.
 *
 * @todo Remove when http://drupal.org/node/660736 is fixed in Drupal core.
 *
 * @param $language
 *   A language code. If not provided the default language will be returned.
 * @return
 *   A language object.
 */
function redirect_language_load($language = LANGUAGE_NONE) {
  $languages = &drupal_static(__FUNCTION__);

  if (!isset($languages)) {
    $languages = language_list();
    $languages[LANGUAGE_NONE] = NULL;
  }

  return isset($languages[$language]) ? $languages[$language] : NULL;
}

/**
 * Build the URL of a redirect for display purposes only.
 */
function redirect_url($path, array $options = array(), $clean_url = NULL) {
  if (!isset($clean_url)) {
    $clean_url = variable_get('clean_url', 0);
  }

  if ($path == '') {
    $path = '<front>';
  }

  $url = $path;

  if (!empty($options['absolute']) && !url_is_external($url)) {
    if (!empty($options['https']) && variable_get('https', FALSE)) {
      $url = $GLOBALS['base_secure_url'] . base_path() . $url;
    }
    else {
      $url = $GLOBALS['base_insecure_url'] . base_path() . $url;
    }
  }

  if (isset($options['query'])) {
    $url .= $clean_url ? '?' : '&';
    $url .= drupal_http_build_query($options['query']);
  }
  if (isset($options['fragment'])) {
    $url .= '#' . $options['fragment'];
  }

  return $url;
}

function redirect_variables() {
  return array(
    'redirect_default_status_code' => 301,
    'redirect_auto_redirect' => TRUE,
    'redirect_warning' => FALSE,
    'redirect_passthrough_querystring' => 0,
    'redirect_page_cache' => 0,
    'redirect_purge_inactive' => 0,
    'redirect_global_home' => 1,
    'redirect_global_clean' => 1,
    'redirect_global_canonical' => 1,
    'redirect_global_admin_paths' => 0,
  );
}

//function redirect_get_redirect_info() {
//  $info = &drupal_static(__FUNCTION__);
//
//  if (!isset($info)) {
//    if ($cache = cache_get('redirect:info')) {
//      $info = $cache->data;
//    }
//    else {
//      $info = module_invoke_all('redirect_info');
//      drupal_alter('redirect_info', $info);
//      cache_set('redirect:info', $info);
//    }
//  }
//
//  return $info;
//}

function redirect_parse_url($url) {
  $url = trim($url, " \t\n\r\0\x0B\/");
  $parsed = parse_url($url);

  if (isset($parsed['fragment'])) {
    $url = substr($url, 0, -strlen($parsed['fragment']));
    $url = trim($url, '#');
  }
  if (isset($parsed['query'])) {
    $url = substr($url, 0, -strlen($parsed['query']));
    $url = trim($url, '?&');
    $parsed['query'] = drupal_get_query_array($parsed['query']);
  }

  // Convert absolute to relative.
  if (isset($parsed['scheme']) && isset($parsed['host'])) {
    $base_secure_url = rtrim($GLOBALS['base_secure_url'] . base_path(), '/');
    $base_insecure_url = rtrim($GLOBALS['base_insecure_url'] . base_path(), '/');
    if (strpos($url, $base_secure_url) === 0) {
      $url = str_replace($base_secure_url, '', $url);
      $parsed['https'] = TRUE;
    }
    elseif (strpos($url, $base_insecure_url) === 0) {
      $url = str_replace($base_insecure_url, '', $url);
    }
  }

  $url = trim($url, '/');

  // Convert to frontpage paths.
  if ($url == '<front>') {
    $url = '';
  }

  //$parsed['url'] = http_build_query($url, HTTP_URL_STRIP_QUERY | HTTP_URL_STRIP_FRAGMENT);
  $parsed['url'] = $url;
  return $parsed;
}

function redirect_status_code_options($code = NULL) {
  $codes = array(
    300 => t('300 Multiple Choices'),
    301 => t('301 Moved Permanently'),
    302 => t('302 Found'),
    303 => t('303 See Other'),
    304 => t('304 Not Modified'),
    305 => t('305 Use Proxy'),
    307 => t('307 Temporary Redirect'),
  );
  return isset($codes[$code]) ? $codes[$code] : $codes;
}

/**
 * Returns if the current page request is a page not found (404 status error).
 *
 * Why the fuck do we have to do this? Why is there not an easier way???
 *
 * @return
 *   TRUE if the current page is a 404, or FALSE otherwise.
 */
function redirect_is_current_page_404() {
  return drupal_get_http_header('Status') == '404 Not Found';
}

/**
 * uasort callback; Compare redirects based on language neutrality and rids.
 */
function _redirect_uasort($a, $b) {
  $a_weight = isset($a['weight']) ? $a['weight'] : 0;
  $b_weight = isset($b['weight']) ? $b['weight'] : 0;
  if ($a_weight != $b_weight) {
    // First sort by weight (case sensitivity).
    return $b_weight < $a_weight;
  }
  elseif ($a['language'] != $b['language']) {
    // Then sort by language specific over language neutral.
    return $a['language'] == LANGUAGE_NONE;
  }
  elseif (isset($a['source_options']['query']) != isset($b['source_options']['query'])) {
    // Then sort by redirects that do not have query strings over ones that do.
    return !isset($a['source_options']['query']);
  }
  else {
    // Lastly sort by the highest redirect ID.
    return $a['rid'] < $b['rid'];
  }
}
